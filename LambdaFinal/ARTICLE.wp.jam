{%@comment

It is an article published on javax0.wordpress.com

Why Lambdas can Access only final Variables

%}\
{%@snip:collect from=src%}
{%@import https://raw.githubusercontent.com/central7/wordpress/main/wp.jim%}
{%@define code($x)=```java$x```%}
{%#reflow
# Introduction

Lambda expressions can use the variables in the scope of the lambda expression, but only if they are final or effectively final.
What is the reason for that?
Why is that?
It is an interesting question because the answer is not apparent and bit opinionated.

There is only one ultimate answer, though: because that is what the Java Language Specification says.
But saying that is boring.
True, but boring.
I prefer the answer that says lambdas can only use final and effectively final local variables because lambdas are not closures.

In the following, I will discuss what final and effectively final mean, the differences between closures and lambdas, and finally, how we can create closures in Java using lambda expressions.
I am not advocating the creation of lambda expression-based closures in Java, nor the abandonment of the idea.

# `final` and effectively final

A local variable is final if we use the `final` keyword when we declare it.
The compiler will also require that the variable will get a value only once.
This value assignment may happen at the location of the declaration, but can be a bit later.
As a matter of fact, there can be multiple lines that assign value to the final variable so long as long the only one of them can execute for each method invocation.
The typical case if when you declare a final variable without assigning value to it and then you have an `if` statement assigning different values in the "then" as well as in the "else" branch.

Needless to say that the variable has to be initialized before the lambda expression is created.

A variable is effectively final if it is not final, but it could be.
It gets an assigned value at the declaration, or can get an assigned value only once.

# Life of a Lambda

A lambda expression is a kind of anonymous class.
The JVM handles it differently and it is more efficient than an anonymous class, not to mention that it is more readable.
From our point of view, however, we can think of it as an inner class.

%}
{%code/
{%@snip Anon%}
%}
{%@reflow
When the lambda expression is created, the JVM creates an instance of the a lambda class that implements the `Function` interface.

%}
{%code/
{%@snip AnonTest%}
%}
{%@reflow
This object will be place on the heap of the JVM memory.
In some cases the compiler may realize that the object cannot get out of the scope of the method, and in this case it may store it in the stack.
This is called local variable escape analysis, that can just put any object on the stack, which cannot escape from the method and may die together with the method return.
For our discussion, however, we can forget this advanced feature of the Java environment.

The lambda is created in the method and it is stored in the stack.
It is alive so long as long there is a hard reference to this object and it is not collected.
If a lambda expression could reference and use a local variable, which lives in the stack, then it would need access to something that is gone after the method returns.
It is not possible.

There are two solutions to overcome this discrepancy.
One is, what Java is following, creating a copy of the value of the variable.
The other one is creating a closure.

# Closure and Groovy

We will look at Groovy examples when talking about closures.
The reason to select Groovy is because it is very close to Java.
We will look at some Groovy examples and for the matter of demonstration we will use Java style as much as possible.
Groovy is more or less compatible with Java, any Java code can be compiled as Groovy source.
The actual semantic may, however, be different slightly.

Groovy solved the issue of local variable accessibility creating closures.
The closure closes the functionality, and the environment into a single object.
For example the following Groovy code
%}
{%code/
{%@snip MyMyClosure%}
%}
{%@reflow
creates a closure, similar to our lambda expression, but it also uses the local variable `z`.
This local variable is not final and not effectively final.
What really happens here is that the compiler creates a new class that contains a field for each local variable used in the closure.
A new local variable references an instance of this new class and the local variable references are all referencing this object and the fields in it.
This object along with the code of the "lambda expression" is the closure.

Since the object is stored on the heap, it stay alive as long as there is a hard reference to it.
The object, which holds the described function has one, so this object will be avaialable so long as long the closure is alive.
%}
{%code/
{%@snip TestMyMyClosure%}
%}
{%@reflow
This is clearly shown in the test execution where the closure increases the `z` amount at each execution.

Closures are lambdas with state.

# Lambda in Java

Java approaches this problem differently.
Instead of creating a new synthetic object to hold the referenced local variables it simply uses the values of the variables.
Lambdas seem to use the variables, but they don't.
They use only constants, they copy the value of the variables.

When designing lambdas there were two options.
I was not part of the team making the decisions, so what I write here is only my opinion, but I am close to sure this was the right decision.
One option could be to copy the value of the variable by the time the lambda is created not caring about the later value change of the local variable.
Could it work?
Inevitably.
Would it be readable?
Many cases it would not be.

The cleaner and more pragmatic and Java like approach is to require that these variables are `final`.
Or at least effectively final.

When designing language elements there are always tradeoff.
On one end there are constructs which provide great power to the hands of the developers.
However, great power requires great responsibility.
Most of the developers are not mature enough to take on the responsibility.

On the other plate of the scale are the constructs that are simple and provide less functionality.
May not solve some problems so elegantly, but you also cannot create unreadable code so easily.
Java is usually going this way.
There is an obfuscated C contest every years almost since the language C started.
Who can write less readable code in that programming language?
Since then the contest was started for almost all languages, except two.
Java and Perl.
In the case of Java the contest would be boring, as you cannot really write obfuscated code in Java.
In the case of Perl the contest is pointless.

# Closure in Java

If you want to have a closure in Java, you can create one yourself.
The Groovy compiler creates the class for you to enclose the local variables, but nothing stops you to create it manually in case you want it in Java.






%}

