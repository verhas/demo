# Annotation Handling and JPMS

All Java developers have heard about annotations. Annotations are with
us since Java 1.5 (or only 1.6 if you insist). Based on my experience
interviewing candidates I feel that most of the Java developers know how
to use annotations. I mean, most of the developers know that it looks
like `@Test`, or `@Override` and that they come with Java or with some
library and they have to be written in front of a class, method,
variable.

A few developer know that you can also define an annotation in your code
using `@interface` and that your code can do some meta programming using
the annotation. Even fewer know that annotations can be processed by
annotation processors and some of them can be processed during run time.

I could continue it but the long story short is that annotations are a
mistery for most of the Java developers. If you feel offended (that is
your problem by the way) or think that I am wrong stating how clueless
related to the annotations most of the Java developers then consider
that the number of programmers, coders, generally, was growing
exponentially during the last 30 years and Java developers, specially,
was doing so during the last 20 years and it is still growing
exponentially. The exponential function has this feature. If the number
of whatnot is growing exponentially then most of the whatnots are young.
That is the reason why most Java developers do not know well annotations
and not because Java developers are .. I do not know.

To be honest, annotation handlign is not something simple. It deserves
an article especially when we want to handle annotations while using
module systems.

During the final touches of the release 1.2.0 of the Java::Geci code
generation framework I ran into a problem that was caused by my wrong
use of annotations and reflection. Then I realized that probably most of
the developers who handle annotations using reflection are doing the
same wrong way. There was hardly any clue on the net to help me
understand the problem. All I found was a GitHub ticket
https://github.com/oracle/graal/issues/1002 and based on the information
there I had to figure out what is really happening.

So let's refresh a bit what annotations are and after that let's have a
look at what we may be doing wrong that was okay so far but may couse
trouble when JPMS comes into the picture.

## What is an annotation?

Annotations are interfaces that are declared using the `interface`
keyword preceeded with the `@` character. This makes the annotation
usable in the code the was we got used to. Using the name of the
annotation interface with the `@` in front of it. The most frequently
used such annotation is `@Override` that the Java compiler is using
during compile time.

Many frameworks use annotations during run-time, others hook into the
compilation phase implementing an annotation processor. I wrote about
annotation processors and how to create one in the atricle
https://javax0.wordpress.com/2013/09/11/dont-write-biolerplate-use-scriapt/
This time we focus on the simpler way: handling annotation during
run-time. We do not even implement the annotation interface, which is a
rarely used possibility but is complex and hard to do as the article
https://javax0.wordpress.com/2016/03/16/implementing-an-annotation-interface/
describes.

To use an annotation during run-time the annotation has to be available
during run-time. By default the annotations are available only during
compile time and do not get into the generated byte-code. It is a common
mistake to forget (I always do) to put the
`@Retention(RetentionPolicy.RUNTIME)` annotation on the annotation
interface and then starting to debug why I cannot see my annotation when
I access it using reflection.

A simple run-time annotation looks like the following:

<!-- snip Demo -->
```java
@Retention(RetentionPolicy.RUNTIME)
@Repeatable(Demos.class)
public @interface Demo {
    String value() default "";
}
```

The annotations have parameters when used on classes, on methods, or on
other annotated elements. These parameters are methods in the interface.
In the example there is only one method declared in the interface. It is
called `value()`. This is a special one. This is a kind of default
method. If there are no other parameters of an annotation interface, or
even if there are but we do not want to use the other parameters and
they all have default values then we can write

```java
@Demo("This is the value")
```

instead of

```java
@Demo(value="This is the value")
```

If there are other parameters that we need to use then we do not have
this shortcut.

As you can see annotations were introduced on top of some existing
structure. Interfaces and classes are used to represent annotations and
There was not something totally new feature introduced into Java.

Starting with Java 1.8 there can be more than one annotation of the same
type on an annotated element. You could have that feature even before
Java 1.8. You could define another annotation, for example

<!-- snip Demos -->
```java
@Retention(RetentionPolicy.RUNTIME)
public @interface Demos {
    Demo[] value();
}
```

and then use the this wrapper annotation on the annotated element, like

<!-- snip DemoClassNonAbbreviated -->
```java
@Demos(value = {
    @Demo("This is a demo class"),
    @Demo("This is the second annotation")})
public class DemoClassNonAbbreviated {
}
``` 

To ease the tendinitis caused by excessive typing Java 1.8 introduced
the annotation `Repeatable` as you can see on the annotation interface
`Demo` and that way the above code can be written simply as

<!-- snip DemoClassAbbreviated -->
```java
@Demo("This is a demo class")
@Demo("This is the second annotation")
public class DemoClassAbbreviated {
}
``` 

